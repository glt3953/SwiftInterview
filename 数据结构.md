# æ•°æ®ç»“æ„
##  ğŸ“š å¸¸ç”¨æ•°æ®ç»“æ„åŠ Swift å®ç°

1. æ•°ç»„ï¼ˆArrayï¼‰
Swift çš„ Array æ˜¯ä¸€ç§æœ‰åºé›†åˆï¼Œæ”¯æŒå¿«é€Ÿç´¢å¼•è®¿é—®ã€‚

```
var numbers = [1, 2, 3, 4, 5]
numbers.append(6)
numbers.remove(at: 2)
```

é¢è¯•é¢˜ç¤ºä¾‹ï¼š
	â€¢	å¦‚ä½•åœ¨ Swift ä¸­åˆå¹¶ä¸¤ä¸ªæ•°ç»„ï¼Ÿ
ç­”æ¡ˆï¼š ä½¿ç”¨ + æ“ä½œç¬¦æˆ– append(contentsOf:) æ–¹æ³•ã€‚

```
let array1 = [1, 2, 3]
let array2 = [4, 5, 6]
let mergedArray = array1 + array2
// æˆ–è€…
var array3 = array1
array3.append(contentsOf: array2)
```

2. å­—å…¸ï¼ˆDictionaryï¼‰

Dictionary æ˜¯é”®å€¼å¯¹é›†åˆï¼Œé€‚ç”¨äºå¿«é€ŸæŸ¥æ‰¾ã€‚

```
var person: [String: String] = ["name": "Alice", "city": "San Jose"]
person["age"] = "30"
```

é¢è¯•é¢˜ç¤ºä¾‹ï¼š
	â€¢	å¦‚ä½•å®‰å…¨åœ°ä»å­—å…¸ä¸­è·å–å€¼ï¼Ÿ
ç­”æ¡ˆï¼š ä½¿ç”¨å¯é€‰ç»‘å®šã€‚

```
if let name = person["name"] {
    print("Name is \(name)")
} else {
    print("Name not found")
}
```



3. é›†åˆï¼ˆSetï¼‰

Set æ˜¯æ— åºä¸”å”¯ä¸€çš„å…ƒç´ é›†åˆã€‚

```
var uniqueNumbers: Set = [1, 2, 3, 3, 4]
uniqueNumbers.insert(5)
```

é¢è¯•é¢˜ç¤ºä¾‹ï¼š
	â€¢	å¦‚ä½•åˆ¤æ–­ä¸¤ä¸ªé›†åˆæ˜¯å¦æœ‰äº¤é›†ï¼Ÿ
ç­”æ¡ˆï¼š ä½¿ç”¨ isDisjoint(with:) æ–¹æ³•ã€‚

```
let setA: Set = [1, 2, 3]
let setB: Set = [3, 4, 5]
let hasIntersection = !setA.isDisjoint(with: setB)
```



4. æ ˆï¼ˆStackï¼‰

Swift æ²¡æœ‰å†…å»ºçš„æ ˆç±»å‹ï¼Œä½†å¯ä»¥ä½¿ç”¨æ•°ç»„æ¨¡æ‹Ÿã€‚

```
struct Stack<T> {
    private var elements: [T] = []

    mutating func push(_ item: T) {
        elements.append(item)
    }

    mutating func pop() -> T? {
        return elements.popLast()
    }

    func peek() -> T? {
        return elements.last
    }

    var isEmpty: Bool {
        return elements.isEmpty
    }
}

```
é¢è¯•é¢˜ç¤ºä¾‹ï¼š
	â€¢	å®ç°ä¸€ä¸ªæ”¯æŒ min() æ“ä½œçš„æ ˆï¼Œè¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(1)ã€‚
ç­”æ¡ˆï¼š ä½¿ç”¨è¾…åŠ©æ ˆå­˜å‚¨å½“å‰æœ€å°å€¼ã€‚

```
struct MinStack {
    private var stack: [Int] = []
    private var minStack: [Int] = []

    mutating func push(_ val: Int) {
        stack.append(val)
        if let last = minStack.last {
            minStack.append(min(val, last))
        } else {
            minStack.append(val)
        }
    }

    mutating func pop() {
        stack.popLast()
        minStack.popLast()
    }

    func top() -> Int? {
        return stack.last
    }

    func getMin() -> Int? {
        return minStack.last
    }
}
```



5. é˜Ÿåˆ—ï¼ˆQueueï¼‰

åŒæ ·å¯ä»¥ä½¿ç”¨æ•°ç»„æˆ–åŒç«¯é˜Ÿåˆ—ï¼ˆDequeï¼‰æ¨¡æ‹Ÿã€‚

struct Queue<T> {
    private var elements: [T] = []

    mutating func enqueue(_ item: T) {
        elements.append(item)
    }

    mutating func dequeue() -> T? {
        return elements.isEmpty ? nil : elements.removeFirst()
    }

    var isEmpty: Bool {
        return elements.isEmpty
    }
}

é¢è¯•é¢˜ç¤ºä¾‹ï¼š
	â€¢	å¦‚ä½•ä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°ä¸€ä¸ªé˜Ÿåˆ—ï¼Ÿ
ç­”æ¡ˆï¼š ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œå…¥é˜Ÿæ—¶å‹å…¥ç¬¬ä¸€ä¸ªæ ˆï¼Œå‡ºé˜Ÿæ—¶å¦‚æœç¬¬äºŒä¸ªæ ˆä¸ºç©ºï¼Œåˆ™å°†ç¬¬ä¸€ä¸ªæ ˆçš„å…ƒç´ é€ä¸ªå¼¹å‡ºå¹¶å‹å…¥ç¬¬äºŒä¸ªæ ˆï¼Œç„¶åå¼¹å‡ºç¬¬äºŒä¸ªæ ˆçš„æ ˆé¡¶å…ƒç´ ã€‚

struct MyQueue {
    private var stack1: [Int] = []
    private var stack2: [Int] = []

    mutating func enqueue(_ x: Int) {
        stack1.append(x)
    }

    mutating func dequeue() -> Int? {
        if stack2.isEmpty {
            while let last = stack1.popLast() {
                stack2.append(last)
            }
        }
        return stack2.popLast()
    }

    func peek() -> Int? {
        if stack2.isEmpty {
            return stack1.first
        } else {
            return stack2.last
        }
    }

    var isEmpty: Bool {
        return stack1.isEmpty && stack2.isEmpty
    }
}



6. é“¾è¡¨ï¼ˆLinked Listï¼‰

Swift æ²¡æœ‰å†…å»ºçš„é“¾è¡¨ç±»å‹ï¼Œéœ€è¦è‡ªå®šä¹‰å®ç°ã€‚

class ListNode<T> {
    var value: T
    var next: ListNode?

    init(_ value: T) {
        self.value = value
        self.next = nil
    }
}

é¢è¯•é¢˜ç¤ºä¾‹ï¼š
	â€¢	å¦‚ä½•æ£€æµ‹é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ï¼Ÿ
ç­”æ¡ˆï¼š ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ³•ã€‚

func hasCycle(_ head: ListNode<Int>?) -> Bool {
    var slow = head
    var fast = head

    while let nextFast = fast?.next?.next {
        slow = slow?.next
        fast = nextFast
        if slow === fast {
            return true
        }
    }
    return false
}



â¸»

ğŸ§  å¸¸è§é¢è¯•é¢˜è§£æ

1. Swift ä¸­çš„å€¼ç±»å‹ä¸å¼•ç”¨ç±»å‹

é—®é¢˜ï¼š Swift ä¸­çš„ struct å’Œ class æœ‰ä½•åŒºåˆ«ï¼Ÿ

ç­”æ¡ˆï¼š
	â€¢	struct æ˜¯å€¼ç±»å‹ï¼Œå¤åˆ¶æ—¶ä¼šå¤åˆ¶æ•´ä¸ªå€¼ã€‚
	â€¢	class æ˜¯å¼•ç”¨ç±»å‹ï¼Œå¤åˆ¶æ—¶ä¼šå¤åˆ¶å¼•ç”¨ã€‚

ç¤ºä¾‹ï¼š

struct Point {
    var x: Int
    var y: Int
}

var p1 = Point(x: 0, y: 0)
var p2 = p1
p2.x = 10
print(p1.x) // è¾“å‡º 0ï¼Œè¯´æ˜ p1 æœªè¢«ä¿®æ”¹

2. Optional çš„ä½¿ç”¨

é—®é¢˜ï¼š å¦‚ä½•å®‰å…¨åœ°è§£åŒ… Optional å€¼ï¼Ÿ

ç­”æ¡ˆï¼š
	â€¢	ä½¿ç”¨å¯é€‰ç»‘å®šï¼ˆif let æˆ– guard letï¼‰ã€‚
	â€¢	ä½¿ç”¨ç©ºåˆè¿ç®—ç¬¦ï¼ˆ??ï¼‰æä¾›é»˜è®¤å€¼ã€‚

ç¤ºä¾‹ï¼š

let optionalString: String? = "Hello"
if let unwrapped = optionalString {
    print(unwrapped)
}

let defaultString = optionalString ?? "Default"
print(defaultString)

3. ä½¿ç”¨é«˜é˜¶å‡½æ•°å¤„ç†é›†åˆ

é—®é¢˜ï¼š å¦‚ä½•ä½¿ç”¨ mapã€filter å’Œ reduceï¼Ÿ

ç­”æ¡ˆï¼š
	â€¢	mapï¼šå¯¹é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œè½¬æ¢ã€‚
	â€¢	filterï¼šç­›é€‰å‡ºæ»¡è¶³æ¡ä»¶çš„å…ƒç´ ã€‚
	â€¢	reduceï¼šå°†é›†åˆä¸­çš„å…ƒç´ åˆå¹¶ä¸ºä¸€ä¸ªå€¼ã€‚

ç¤ºä¾‹ï¼š

let numbers = [1, 2, 3, 4, 5]
let squared = numbers.map { $0 * $0 } // [1, 4, 9, 16, 25]
let even = numbers.filter { $0 % 2 == 0 } // [2, 4]
let sum = numbers.reduce(0, +) // 15

4. å®ç°å•ä¾‹æ¨¡å¼

é—®é¢˜ï¼š å¦‚ä½•åœ¨ Swift ä¸­å®ç°å•ä¾‹æ¨¡å¼ï¼Ÿ

ç­”æ¡ˆï¼š ä½¿ç”¨é™æ€å¸¸é‡å’Œç§æœ‰åˆå§‹åŒ–æ–¹æ³•ã€‚

ç¤ºä¾‹ï¼š

class Singleton {
    static let shared = Singleton()
    private init() {}
}


â¸»

ğŸ”— æ¨èèµ„æº
	â€¢	Swift é¢è¯•é¢˜åŠç­”æ¡ˆæ•´ç†ï¼Œæœ€æ–°é¢è¯•é¢˜ - CSDNåšå®¢
	â€¢	iOS Swiftå¼€å‘é¢è¯•é¢˜æ€»ç»“ - ç¨€åœŸæ˜é‡‘
	â€¢	iOSé¢è¯•é¢˜Swift(ä¸‰) - çŸ¥ä¹ä¸“æ 
	â€¢	æ•°æ®ç»“æ„& ç®—æ³•in Swift ï¼ˆä¸€ï¼‰ï¼šSwiftåŸºç¡€å’Œæ•°æ®ç»“æ„ - J_Knight_

å¦‚æœæ‚¨éœ€è¦æ›´å¤šå…³äºç‰¹å®šæ•°æ®ç»“æ„æˆ–ç®—æ³•çš„ Swift å®ç°ç¤ºä¾‹ï¼Œæ¬¢è¿ç»§ç»­æé—®ï¼
## LRU ç¼“å­˜ç­–ç•¥ï¼ˆLeast Recently Usedï¼‰
åŸç†ï¼š
	â€¢	ä¿ç•™æœ€è¿‘æœ€å¸¸è®¿é—®çš„å†…å®¹ï¼Œæ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®ã€‚
	â€¢	å¯ç”¨ Dictionary + Double Linked List å®ç°ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(1)ã€‚

Swift å®ç°ç®€åŒ–ç‰ˆï¼ˆç”¨ NSCache ä¹Ÿèƒ½å®ç° LRUï¼‰ï¼š

```
class LRUCache<Key: Hashable, Value> {
    private var capacity: Int
    private var cache: [Key: Value] = [:]
    private var keys: [Key] = []

    init(capacity: Int) {
        self.capacity = capacity
    }

    func get(_ key: Key) -> Value? {
        if let value = cache[key] {
            moveToTop(key)
            return value
        }
        return nil
    }

    func put(_ key: Key, value: Value) {
        if cache[key] != nil {
            moveToTop(key)
        } else {
            if keys.count >= capacity {
                let removed = keys.removeFirst()
                cache.removeValue(forKey: removed)
            }
            keys.append(key)
        }
        cache[key] = value
    }

    private func moveToTop(_ key: Key) {
        keys.removeAll { $0 == key }
        keys.append(key)
    }
}
```

ğŸ“Œ LRU ç¼“å­˜çš„æ ¸å¿ƒæ•°æ®ç»“æ„

LRU ç¼“å­˜ç»“åˆäº†ä¸¤ç§æ•°æ®ç»“æ„ï¼š
	1.	å“ˆå¸Œè¡¨ï¼ˆHash Mapï¼‰ï¼šç”¨äºä»¥ O(1) æ—¶é—´å¤æ‚åº¦å¿«é€Ÿè®¿é—®ç¼“å­˜ä¸­çš„æ•°æ®ã€‚
	2.	åŒå‘é“¾è¡¨ï¼ˆDoubly Linked Listï¼‰ï¼šç”¨äºç»´æŠ¤æ•°æ®çš„ä½¿ç”¨é¡ºåºï¼Œæœ€è¿‘ä½¿ç”¨çš„æ•°æ®æ”¾åœ¨é“¾è¡¨å¤´éƒ¨ï¼Œæœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®æ”¾åœ¨é“¾è¡¨å°¾éƒ¨ã€‚

è¿™ç§ç»„åˆä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å®Œæˆä»¥ä¸‹æ“ä½œï¼š
	â€¢	è·å–æ•°æ®ï¼ˆgetï¼‰ï¼šé€šè¿‡å“ˆå¸Œè¡¨å¿«é€Ÿå®šä½æ•°æ®ï¼Œå¹¶å°†å…¶å¯¹åº”çš„èŠ‚ç‚¹ç§»åŠ¨åˆ°é“¾è¡¨å¤´éƒ¨ï¼Œè¡¨ç¤ºæœ€è¿‘ä½¿ç”¨ã€‚
	â€¢	æ·»åŠ æ•°æ®ï¼ˆputï¼‰ï¼šå¦‚æœæ•°æ®å·²å­˜åœ¨ï¼Œæ›´æ–°å…¶å€¼å¹¶ç§»åŠ¨åˆ°é“¾è¡¨å¤´éƒ¨ï¼›å¦‚æœæ•°æ®ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹æ’å…¥é“¾è¡¨å¤´éƒ¨ï¼Œå¹¶åœ¨å“ˆå¸Œè¡¨ä¸­æ·»åŠ å¯¹åº”çš„é”®å€¼å¯¹ï¼›å¦‚æœç¼“å­˜å·²æ»¡ï¼Œç§»é™¤é“¾è¡¨å°¾éƒ¨çš„èŠ‚ç‚¹ï¼Œå¹¶ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤å¯¹åº”çš„é”®å€¼å¯¹ã€‚

ğŸ”„ æ“ä½œç¤ºä¾‹

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå®¹é‡ä¸º 3 çš„ LRU ç¼“å­˜ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š 
	1.	put(1, A)
	2.	put(2, B)
	3.	put(3, C)
	4.	get(2)
	5.	put(4, D)

æ“ä½œè¿‡ç¨‹å¦‚ä¸‹ï¼š
	â€¢	åˆå§‹çŠ¶æ€ï¼šç¼“å­˜ä¸ºç©ºã€‚
	â€¢	æ“ä½œ 1ï¼šæ·»åŠ é”®å€¼å¯¹ (1, A)ï¼Œé“¾è¡¨çŠ¶æ€ä¸ºï¼š  

```
Head <-> (1, A) <-> Tail
```
â€¢	æ“ä½œ 2ï¼šæ·»åŠ é”®å€¼å¯¹ (2, B)ï¼Œé“¾è¡¨çŠ¶æ€ä¸ºï¼š
```
Head <-> (2, B) <-> (1, A) <-> Tail
```
â€¢	æ“ä½œ 3ï¼šæ·»åŠ é”®å€¼å¯¹ (3, C)ï¼Œé“¾è¡¨çŠ¶æ€ä¸ºï¼š
```
Head <-> (3, C) <-> (2, B) <-> (1, A) <-> Tail
```
â€¢	æ“ä½œ 4ï¼šè®¿é—®é”® 2ï¼ŒèŠ‚ç‚¹ (2, B) ç§»åŠ¨åˆ°é“¾è¡¨å¤´éƒ¨ï¼Œé“¾è¡¨çŠ¶æ€ä¸ºï¼š
```
Head <-> (2, B) <-> (3, C) <-> (1, A) <-> Tail
```
â€¢	æ“ä½œ 5ï¼šæ·»åŠ é”®å€¼å¯¹ (4, D)ï¼Œç¼“å­˜å·²æ»¡ï¼Œç§»é™¤é“¾è¡¨å°¾éƒ¨çš„èŠ‚ç‚¹ (1, A)ï¼Œç„¶åå°†æ–°èŠ‚ç‚¹æ’å…¥é“¾è¡¨å¤´éƒ¨ï¼Œé“¾è¡¨çŠ¶æ€ä¸ºï¼š
```
Head <-> (4, D) <-> (2, B) <-> (3, C) <-> Tail
```